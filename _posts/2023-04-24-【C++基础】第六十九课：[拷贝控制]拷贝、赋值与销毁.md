---
layout:     post
title:      【C++基础】第六十九课：[拷贝控制]拷贝、赋值与销毁
subtitle:   拷贝控制操作，拷贝构造函数，拷贝赋值运算符，析构函数，阻止拷贝，=delete
date:       2023-04-24
author:     x-jeff
header-img: blogimg/20220407.jpg
catalog: true
tags:
    - C++ Series
---
>【C++基础】系列博客为参考[《C++ Primer中文版（第5版）》](https://www.phei.com.cn/module/goods/wssd_content.jsp?bookid=37655)（**C++11标准**）一书，自己所做的读书笔记。  
>本文为原创文章，未经本人允许，禁止转载。转载请注明出处。

# 1.拷贝控制

当定义一个类时，我们显式地或隐式地指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作，包括：**拷贝构造函数**（copy constructor）、**拷贝赋值运算符**（copy-assignment operator）、**移动构造函数**（move constructor）、**移动赋值运算符**（move-assignment operator）和**析构函数**（destructor）。拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。析构函数定义了当此类型对象销毁时做什么。我们称这些操作为**拷贝控制操作**（copy control）。

如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作。因此，很多类会忽略这些拷贝控制操作。但是，对一些类来说，依赖这些操作的默认定义会导致灾难。

# 2.拷贝构造函数

如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。

```c++
class Foo {
public:
	Foo(); //默认构造函数
	Foo(const Foo&); //拷贝构造函数
};
```

拷贝构造函数的第一个参数必须是一个引用类型。虽然我们可以定义一个接受非const引用的拷贝构造函数，但此参数几乎总是一个const的引用。拷贝构造函数在几种情况下都会被隐式地使用。因此，拷贝构造函数通常不应该是[explicit](http://shichaoxin.com/2022/07/13/C++基础-第四十五课-类-构造函数再探/#43抑制构造函数定义的隐式转换)的。

## 2.1.合成拷贝构造函数

如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与[合成默认构造函数](http://shichaoxin.com/2022/05/22/C++基础-第四十一课-类-定义抽象数据类型/#51合成的默认构造函数)不同，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。

对某些类来说，**合成拷贝构造函数**（synthesized copy constructor）用来阻止我们拷贝该类类型的对象。而一般情况，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。编译器从给定对象中依次将每个非static成员拷贝到正在创建的对象中。

每个成员的类型决定了它如何拷贝：对类类型的成员，会使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝。虽然我们不能直接拷贝一个数组，但合成拷贝构造函数会逐元素地拷贝一个数组类型的成员。如果数组元素是类类型，则使用元素的拷贝构造函数来进行拷贝。

作为一个例子，我们的Sales\_data类的合成拷贝构造函数等价于：

```c++
class Sales_data {
public:
	//其他成员和构造函数的定义，如前
	//与合成的拷贝构造函数等价的拷贝构造函数的声明
	Sales_data(const Sales_data&);
private:
	std::string bookNo;
	int units_sold = 0;
	double revenue = 0.0;
};
//与Sales_data的合成的拷贝构造函数等价
Sales_data::Sales_data(const Sales_data &orig) :
	bookNo(orig.bookNo), //使用string的拷贝构造函数
	units_sold(orig.units_sold), //拷贝orig.units_sold
	revenue(orig.revenue) //拷贝orig.revenue
	{ } //空函数体
```

## 2.2.拷贝初始化

现在，我们可以完全理解直接初始化和拷贝初始化之间的差异了：

```c++
string dots(10, '.'); //直接初始化
string s(dots); //直接初始化
string s2 = dots; //拷贝初始化
string null_book = "9-999-99999-9"; //拷贝初始化
string nines = string(100, '9'); //拷贝初始化
```

当使用直接初始化时，我们实际上是要求编译器使用普通的[函数匹配](http://shichaoxin.com/2022/04/01/C++基础-第三十九课-函数匹配/)来选择与我们提供的参数最匹配的构造函数。当我们使用**拷贝初始化**（copy initialization）时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行[类型转换](http://shichaoxin.com/2022/07/13/C++基础-第四十五课-类-构造函数再探/#4隐式的类类型转换)。

拷贝初始化通常使用拷贝构造函数来完成。但是，如果一个类有一个移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成。但现在，我们只需了解拷贝初始化何时发生，以及拷贝初始化是依靠拷贝构造函数或移动构造函数来完成的就可以了。

拷贝初始化不仅在我们用=定义变量时会发生，在下列情况下也会发生：

* 将一个对象作为实参传递给一个非引用类型的形参。
* 从一个返回类型为非引用类型的函数返回一个对象。
* 用花括号列表初始化一个数组中的元素或一个[聚合类](http://shichaoxin.com/2022/07/13/C++基础-第四十五课-类-构造函数再探/#5聚合类)中的成员。

某些类类型还会对它们所分配的对象使用拷贝初始化。例如，当我们初始化标准库容器或是调用其[insert或push](http://shichaoxin.com/2022/10/15/C++基础-第五十二课-顺序容器-顺序容器操作/)成员时，容器会对其元素进行拷贝初始化。与之相对，用[emplace](http://shichaoxin.com/2022/10/15/C++基础-第五十二课-顺序容器-顺序容器操作/)成员创建的元素都进行直接初始化。

>个人理解：
>
>insert和push都用于向容器中添加元素。它们都接受一个参数，表示要添加的元素。这些函数会将传入的参数拷贝到容器中的新元素。
>
>例如，如果有一个`std::vector<int>`，并使用`push_back`添加一个整数元素，实际上是将该整数的拷贝存储到向量中。这是因为容器需要在内部管理元素的生命周期，因此它们通过拷贝初始化来创建元素的副本。这确保了容器拥有自己的独立副本，而不会依赖于外部对象的生存期。类似的，insert也是使用拷贝初始化将元素添加到容器中。
>
>而emplace则提供了一种更高效的方法来向容器中添加元素。它们采用的是直接初始化的方式，通过在容器内部构造元素，避免了不必要的拷贝操作。

## 2.3.参数和返回值

在函数调用过程中，具有非引用类型的参数要进行拷贝初始化。类似的，当一个函数具有非引用的返回类型时，返回值会被用来初始化调用方的结果。

拷贝构造函数被用来初始化非引用类类型参数，这一特性解释了为什么拷贝构造函数自己的参数必须是引用类型。如果其参数不是引用类型，则调用永远也不会成功——为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环。

## 2.4.编译器可以绕过拷贝构造函数

在拷贝初始化过程中，编译器可以（但不是必须）跳过拷贝/移动构造函数，直接创建对象。即，编译器被允许将下面的代码：

```c++
string null_book = "9-999-99999-9"; //拷贝初始化
```

改写为：

```c++
string null_book("9-999-99999-9"); //编译器略过了拷贝构造函数
```

但是，即使编译器略过了拷贝/移动构造函数，但在这个程序点上，拷贝/移动构造函数必须是存在且可访问的（例如，不能是private的）。

# 3.拷贝赋值运算符

与类控制其对象如何初始化一样，类也可以控制其对象如何赋值：

```c++
Sales_data trans, accum;
trans = accum; //使用Sales_data的拷贝赋值运算符
```

与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个。

## 3.1.重载赋值运算符

重载运算符本质上是函数，其名字由operator关键字后接表示要定义的运算符的符号组成。因此，赋值运算符就是一个名为operator=的函数。类似于任何其他函数，运算符函数也有一个返回类型和一个参数列表。

重载运算符的参数表示运算符的运算对象。某些运算符，包括赋值运算符，必须定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的[this](http://shichaoxin.com/2022/05/22/C++基础-第四十一课-类-定义抽象数据类型/#32引入this)参数。对于一个二元运算符，例如赋值运算符，其右侧运算对象作为显式参数传递。

拷贝赋值运算符接受一个与其所在类相同类型的参数：

```c++
class Foo {
public:
	Foo& operator=(const Foo&); //赋值运算符
	// ...
};
```

为了与内置类型的[赋值](http://shichaoxin.com/2021/04/19/C++基础-第二十三课-赋值运算符/)保持一致，赋值运算符通常返回一个指向其左侧运算对象的引用。另外值得注意的是，标准库通常要求保存在容器中的类型要具有赋值运算符，且其返回值是左侧运算对象的引用。

## 3.2.合成拷贝赋值运算符

与处理拷贝构造函数一样，如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个**合成拷贝赋值运算符**（synthesized copy- assignment operator）。类似拷贝构造函数，对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值。如果拷贝赋值运算符并非出于此目的，它会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员，这一工作是通过成员类型的拷贝赋值运算符来完成的。对于数组类型的成员，逐个赋值数组元素。合成拷贝赋值运算符返回一个指向其左侧运算对象的引用。

作为一个例子，下面的代码等价于Sales\_data的合成拷贝赋值运算符：

```c++
//等价于合成拷贝赋值运算符
Sales_data& Sales_data::operator=(const Sales_data &rhs)
{
	bookNo = rhs.bookNo; //调用string::operator=
	units_sold = rhs.units_sold; //使用内置的int赋值
	revenue = rhs.revenue; //使用内置的double赋值
	return *this; //返回一个此对象的引用
}
```

# 4.析构函数

析构函数执行与构造函数相反的操作：构造函数初始化对象的非static数据成员，还可能做一些其他工作；析构函数释放对象使用的资源，并销毁对象的非static数据成员。

析构函数是类的一个成员函数，名字由波浪号接类名构成。它没有返回值，也不接受参数：

```c++
class Foo {
public:
	~Foo(); //析构函数
	// ...
};
```

由于析构函数不接受参数，因此它不能被重载。对一个给定类，只会有唯一一个析构函数。

## 4.1.析构函数完成什么工作

如同[构造函数](http://shichaoxin.com/2022/07/13/C++基础-第四十五课-类-构造函数再探/#1构造函数初始值列表)有一个初始化部分和一个函数体，析构函数也有一个函数体和一个析构部分。在一个构造函数中，成员的初始化是在函数体执行之前完成的，且[按照它们在类中出现的顺序进行初始化](http://shichaoxin.com/2022/07/13/C++基础-第四十五课-类-构造函数再探/#12成员初始化的顺序)。在一个析构函数中，首先执行函数体，然后销毁成员。**成员按初始化顺序的逆序销毁**。

在对象最后一次使用之后，析构函数的函数体可执行类设计者希望执行的任何收尾工作。通常，析构函数释放对象在生存期分配的所有资源。

在一个析构函数中，不存在类似构造函数中初始化列表的东西来控制成员如何销毁，析构部分是隐式的。成员销毁时发生什么完全依赖于成员的类型。销毁类类型的成员需要执行成员自己的析构函数。内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。

>隐式销毁一个内置指针类型的成员不会delete它所指向的对象。
>
>个人理解：
>
>在C++中，当使用`new`运算符创建一个对象时，它会在堆上动态分配内存，并返回一个指向该对象的指针。如果忘记调用`delete`来释放这个指针指向的对象，就会导致内存泄漏，因为该对象的内存将永远无法被回收。
>
>那么在类中，如果这个指针类型的成员变量没有在析构函数中调用`delete`来释放指向的对象，当该类的对象销毁时，这个指针会被销毁，但它所指向的对象仍然存在于内存中（即指向的内存并没有被释放），造成了潜在的内存泄漏。
>
>为了避免这种情况，应该在类的析构函数中显式调用`delete`来释放指针所指向的对象，以确保内存被正确释放。

与普通指针不同，[智能指针](http://shichaoxin.com/2023/03/15/C++基础-第六十六课-动态内存-动态内存与智能指针/#2shared_ptr类)是类类型，所以具有析构函数。因此，与普通指针不同，智能指针成员在析构阶段会被自动销毁。

## 4.2.什么时候会调用析构函数

无论何时一个对象被销毁，就会自动调用其析构函数：

* 变量在离开其作用域时被销毁。
* 当一个对象被销毁时，其成员被销毁。
* 容器（无论是标准库容器还是数组）被销毁时，其元素被销毁。
* 对于动态分配的对象，当对指向它的指针应用[delete运算符](http://shichaoxin.com/2023/03/15/C++基础-第六十六课-动态内存-动态内存与智能指针/#3直接管理内存)时被销毁。
* 对于临时对象，当创建它的完整表达式结束时被销毁。

由于析构函数自动运行，我们的程序可以按需要分配资源，而（通常）无须担心何时释放这些资源。

例如，下面代码片段定义了四个Sales\_data对象：

```c++
{ //新作用域
	//p和p2指向动态分配的对象
	Sales_data *p = new Sales_data; //p是一个内置指针
	auto p2 = make_shared<Sales_data>(); //p2是一个shared_ptr
	Sales_data item(*p); //拷贝构造函数将*p拷贝到item中
	vector<Sales_data> vec; //局部对象
	vec.push_back(*p2); //拷贝p2指向的对象
	delete p; //对p指向的对象执行析构函数
}
//退出局部作用域；对item、p2和vec调用析构函数
//销毁p2会递减其引用计数；如果引用计数变为0，对象被释放
//销毁vec会销毁它的元素
```

每个Sales\_data对象都包含一个string成员，它分配动态内存来保存bookNo成员中的字符。但是，我们的代码唯一需要直接管理的内存就是我们直接分配的Sales\_data对象。我们的代码只需直接释放绑定到p的动态分配对象。

其他Sales\_data对象会在离开作用域时被自动销毁。当程序块结束时，vec、p2和item都离开了作用域，意味着在这些对象上分别会执行vector、shared\_ptr和Sales\_data的析构函数。vector的析构函数会销毁我们添加到vec的元素。shared\_ptr的析构函数会递减p2指向的对象的引用计数。在本例中，引用计数会变为0，因此shared\_ptr的析构函数会delete p2分配的Sales\_data对象。

在所有情况下，Sales\_data的析构函数都会隐式地销毁bookNo成员。销毁bookNo会调用string的析构函数，它会释放用来保存ISBN的内存。

>当指向一个对象的引用或指针离开作用域时，析构函数不会执行。

## 4.3.合成析构函数

当一个类未定义自己的析构函数时，编译器会为它定义一个**合成析构函数**（synthesized destructor）。类似拷贝构造函数和拷贝赋值运算符，对于某些类，合成析构函数被用来阻止该类型的对象被销毁。如果不是这种情况，合成析构函数的函数体就为空。

例如，下面的代码片段等价于Sales\_data的合成析构函数：

```c++
class Sales_data {
public:
	//成员会被自动销毁，除此之外不需要做其他事情
	~Sales_data() { }
	//其他成员的定义，如前
};
```

在（空）析构函数体执行完毕后，成员会被自动销毁。特别的，string的析构函数会被调用，它将释放bookNo成员所用的内存。

认识到析构函数体自身并不直接销毁成员是非常重要的。成员是在析构函数体之后隐含的析构阶段中被销毁的。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。

# 5.三/五法则

如前所述，有三个基本操作可以控制类的拷贝操作：拷贝构造函数、拷贝赋值运算符和析构函数。而且，在新标准下，一个类还可以定义一个移动构造函数和一个移动赋值运算符。

C++语言并不要求我们定义所有这些操作：可以只定义其中一个或两个，而不必定义所有。但是，这些操作通常应该被看作一个整体。通常，只需要其中一个操作，而不需要定义所有操作的情况是很少见的。

## 5.1.需要析构函数的类也需要拷贝和赋值操作

当我们决定一个类是否要定义它自己版本的拷贝控制成员时，一个基本原则是首先确定这个类是否需要一个析构函数。通常，对析构函数的需求要比对拷贝构造函数或赋值运算符的需求更加明显。如果这个类需要一个析构函数，我们几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符。

举个例子：

```c++
class HasPtr {
public:
	HasPtr(const std::string &s = std::string()) : ps(new std::string(s)), i(0) { }
private:
	std::string *ps;
	int i;
};
```

这个类在构造函数中分配动态内存。合成析构函数不会delete一个指针数据成员。因此，此类需要定义一个析构函数来释放构造函数分配的内存。

应该怎么做可能还有点儿不清晰，但基本原则告诉我们，HasPtr也需要一个拷贝构造函数和一个拷贝赋值运算符。

如果我们为HasPtr定义一个析构函数，但使用合成版本的拷贝构造函数和拷贝赋值运算符，考虑会发生什么：

```c++
class HasPtr {
public:
	HasPtr(const std::string &s = std::string()) : ps(new std::string(s)), i(0) { }
	~HasPtr() { delete ps; }
	//错误：HasPtr需要一个拷贝构造函数和一个拷贝赋值运算符
	//其他成员的定义，如前
};
```

在这个版本的类定义中，构造函数中分配的内存将在HasPtr对象销毁时被释放。但不幸的是，我们引入了一个严重的错误！这个版本的类使用了合成的拷贝构造函数和拷贝赋值运算符。这些函数简单拷贝指针成员，这意味着多个HasPtr对象可能指向相同的内存：

```c++
HasPtr f(HasPtr hp) //HasPtr是传值参数，所以将被拷贝
{
	HasPtr ret = hp; //拷贝给定的HasPtr
	//处理ret
	return ret; //ret和hp被销毁
}
```

当f返回时，hp和ret都被销毁，在两个对象上都会调用HasPtr的析构函数。此析构函数会delete ret和hp中的指针成员。但这两个对象包含相同的指针值。此代码会导致此指针被delete两次，这显然是一个错误。将要发生什么是未定义的。

此外，f的调用者还会使用传递给f的对象：

```c++
HasPtr p("some values");
f(p); //当f结束时，p.ps指向的内存被释放
HasPtr q(p); //现在p和q都指向无效内存！
```

p（以及q）指向的内存不再有效，在hp（或ret！）销毁时它就被归还给系统了。

## 5.2.需要拷贝操作的类也需要赋值操作，反之亦然

虽然很多类需要定义所有（或是不需要定义任何）拷贝控制成员，但某些类所要完成的工作，只需要拷贝或赋值操作，不需要析构函数。

作为一个例子，考虑一个类为每个对象分配一个独有的、唯一的序号。这个类需要一个拷贝构造函数为每个新创建的对象生成一个新的、独一无二的序号。除此之外，这个拷贝构造函数从给定对象拷贝所有其他数据成员。这个类还需要自定义拷贝赋值运算符来避免将序号赋予目的对象。但是，这个类不需要自定义析构函数。

这个例子引出了第二个基本原则：如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。反之亦然——如果一个类需要一个拷贝赋值运算符，几乎可以肯定它也需要一个拷贝构造函数。然而，无论是需要拷贝构造函数还是需要拷贝赋值运算符都不必然意味着也需要析构函数。

# 6.使用=default

我们可以通过将拷贝控制成员定义为=default来显式地要求编译器生成合成的版本：

```c++
class Sales_data {
public:
	//拷贝控制成员；使用default
	Sales_data() = default;
	Sales_data(const Sales_data&) =default;
	Sales_data& operator=(const Sales_data &);
	~Sales_data() = default;
	//其他成员的定义，如前
};
```

当我们在类内用=default修饰成员的声明时，合成的函数将隐式地声明为内联的（就像任何其他类内声明的成员函数一样）。如果我们不希望合成的成员是内联函数，应该只对成员的类外定义使用=default，就像对拷贝赋值运算符所做的那样。

>=default的作用是告诉编译器生成默认的函数实现，避免手动编写这些函数，从而简化代码。它通常用于特殊成员函数，以确保类的行为符合编译器默认生成的实现。
>
>我们只能对具有合成版本的成员函数使用=default（即，默认构造函数或拷贝控制成员）。

# 7.阻止拷贝

>大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显式地。

虽然大多数类应该定义（而且通常也的确定义了）拷贝构造函数和拷贝赋值运算符，但对某些类来说，这些操作没有合理的意义。在此情况下，定义类时必须采用某种机制阻止拷贝或赋值。例如，iostream类阻止了拷贝，以避免多个对象写入或读取相同的IO缓冲。为了阻止拷贝，看起来可能应该不定义拷贝控制成员。但是，这种策略是无效的：如果我们的类未定义这些操作，编译器为它生成合成的版本。

## 7.1.定义删除的函数

在新标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为**删除的函数**（deleted function）来阻止拷贝。删除的函数是这样一种函数：我们虽然声明了它们，但不能以任何方式使用它们。在函数的参数列表后面加上=delete来指出我们希望将它定义为删除的：

```c++
struct NoCopy {
	NoCopy() = default; //使用合成的默认构造函数
	NoCopy(const NoCopy&) = delete; //阻止拷贝
	NoCopy &operator=(const NoCopy&) = delete; //阻止赋值
	~NoCopy() = default; //使用合成的析构函数
	//其他成员
};
```

=delete通知编译器（以及代码读者），我们不希望定义这些成员。

与=default不同，=delete必须出现在函数第一次声明的时候。

与=default的另一个不同之处是，我们可以对任何函数指定=delete（我们只能对编译器可以合成的默认构造函数或拷贝控制成员使用=default）。虽然删除函数的主要用途是禁止拷贝控制成员，但当我们希望引导函数匹配过程时，删除函数有时也是有用的。

## 7.2.析构函数不能是删除的成员

值得注意的是，我们不能删除析构函数。如果析构函数被删除，就无法销毁此类型的对象了。对于一个删除了析构函数的类型，编译器将不允许定义该类型的变量或创建该类的临时对象。而且，如果一个类有某个成员的类型删除了析构函数，我们也不能定义该类的变量或临时对象。因为如果一个成员的析构函数是删除的，则该成员无法被销毁。而如果一个成员无法被销毁，则对象整体也就无法被销毁了。

对于删除了析构函数的类型，虽然我们不能定义这种类型的变量或成员，但可以动态分配这种类型的对象。但是，不能释放这些对象：

```c++
struct NoDtor {
	NoDtor() = default; //使用合成默认构造函数
	~NoDtor() = delete; //我们不能销毁NoDtor类型的对象
};
NoDtor nd; //错误：NoDtor的析构函数是删除的
NoDtor *p = new NoDtor(); //正确：但我们不能delete p
delete p; //错误：NoDtor的析构函数是删除的
```

## 7.3.合成的拷贝控制成员可能是删除的

如前所述，如果我们未定义拷贝控制成员，编译器会为我们定义合成的版本。类似的，如果一个类未定义构造函数，编译器会为其合成一个默认构造函数。对某些类来说，编译器将这些合成的成员定义为删除的函数：

* 如果类的某个成员的析构函数是删除的或不可访问的（例如，是private的），则类的合成析构函数被定义为删除的。
* 如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。如果类的某个成员的析构函数是删除的或不可访问的，则类合成的拷贝构造函数也被定义为删除的。
* 如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个const的或引用成员，则类的合成拷贝赋值运算符被定义为删除的。
* 如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器，或是类有一个const成员，它没有类内初始化器且其类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的。

本质上，这些规则的含义是：如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。

一个成员有删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义为删除的，这看起来可能有些奇怪。其原因是，如果没有这条规则，我们可能会创建出无法销毁的对象。

对于具有引用成员或无法默认构造的const成员的类，编译器不会为其合成默认构造函数，这应该不奇怪。同样不出人意料的规则是：如果一个类有const成员，则它不能使用合成的拷贝赋值运算符。毕竟，此运算符试图赋值所有成员，而将一个新值赋予一个const对象是不可能的。

虽然我们可以将一个新值赋予一个引用成员，但这样做改变的是引用指向的对象的值，而不是引用本身。如果为这样的类合成拷贝赋值运算符，则赋值后，左侧运算对象仍然指向与赋值前一样的对象，而不会与右侧运算对象指向相同的对象。由于这种行为看起来并不是我们所期望的，因此对于有引用成员的类，合成拷贝赋值运算符被定义为删除的。

## 7.4.private拷贝控制

在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private的来阻止拷贝：

```c++
class PrivateCopy {
	//无访问说明符；接下来的成员默认为private的
	//拷贝控制成员是private的，因此普通用户代码无法访问
	PrivateCopy(const PrivateCopy&);
	PrivateCopy &operator=(const PrivateCopy&);
	//其他成员
public:
	PrivateCopy() = default; //使用合成的默认构造函数
	~PrivateCopy(); //用户可以定义此类型的对象，但无法拷贝它们
};
```

由于析构函数是public的，用户可以定义PrivateCopy类型的对象。但是，由于拷贝构造函数和拷贝赋值运算符是private的，用户代码将不能拷贝这个类型的对象。但是，[友元](http://shichaoxin.com/2022/06/03/C++基础-第四十二课-类-访问控制与封装/#2友元)和成员函数仍旧可以拷贝对象。为了阻止[友元](http://shichaoxin.com/2022/06/03/C++基础-第四十二课-类-访问控制与封装/#2友元)和成员函数进行拷贝，我们将这些拷贝控制成员声明为private的，但并不定义它们。

声明但不定义一个成员函数是合法的，对此只有一个例外，后续博客会有介绍。试图访问一个未定义的成员将导致一个链接时错误。通过声明（但不定义）private的拷贝构造函数，我们可以预先阻止任何拷贝该类型对象的企图：试图拷贝对象的用户代码将在编译阶段被标记为错误；成员函数或[友元](http://shichaoxin.com/2022/06/03/C++基础-第四十二课-类-访问控制与封装/#2友元)函数中的拷贝操作将会导致链接时错误。

>希望阻止拷贝的类应该使用=delete来定义它们自己的拷贝构造函数和拷贝赋值运算符，而不应该将它们声明为private的。