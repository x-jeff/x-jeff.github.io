---
layout:     post
title:      【C++基础】第六课：类型转换
subtitle:   原码，反码，补码，类型转换
date:       2019-04-24
author:     x-jeff
header-img: blogimg/20190424.jpg
catalog: true
tags:
    - C++ Series
---
>【C++基础】系列博客为参考[《C++ Primer中文版（第5版）》](https://www.phei.com.cn/module/goods/wssd_content.jsp?bookid=37655)（**C++11标准**）一书，自己所做的读书笔记。  
>本文为原创文章，未经本人允许，禁止转载。转载请注明出处。

# 1.机器数、真值

## 1.1.机器数

一个数在计算机中的二进制表示形式，叫做这个数的机器数。机器数是带符号的，其最高位存放符号，非负为0，负数为1。例如：二进制数`0000 0011`为十进制数3，二进制数`1000 0011`为十进制数-3。

上述的`0000 0011`和`1000 0011`即为机器数。

## 1.2.真值

如果机器数`1000 0011`的最高位不再是符号位，则其对应的值不再是-3，而是$2^7+2^1+2^0=128+2+1=131$。因此，为了区分这种情况，将带符号位的机器数对应的真正数值称为机器数的真值。

# 2.原码、反码、补码

原码、反码、补码是机器存储一个具体数字的编码方式。

## 2.1.原码

最高位为符号位，以8位二进制数为例：

* $+1=[0000 0001]_原$
* $-1=[1000 0001]_原$

8位二进制数的取值范围为：`1111 1111`~`0111 1111`，即-127～127。

## 2.2.反码

* 正数的反码就是其本身。
* 负数的反码是在符号位不变的基础上，其余位取返。

以8位二进制数为例：

* $+1=[0000 0001]_反$
* $-1=[1111 1110]_反$

## 2.3.补码

* 正数的补码就是其本身。
* 负数的补码就是在其反码的基础上加1。

以8位二进制数为例：

* $+1=[0000 0001]_补$
* $-1=[1111 1111]_补$

## 2.4.为何要使用原码、反码、补码

对于计算机来说，加减是最基础的运算。如果让计算机在进行加减运算时去辨识符号位，可能会使计算机的基础电路设计变得非常复杂，因此考虑让符号位也参与到加减运算中，从而就衍生出了原码、反码和补码。

例如十进制数的计算：$1-1=0$，我们用原码试验一下：

$(+1)+(-1)=[0000 0001]_原+[1000 0001]_原=[1000 0010]_原=-2$

这个结果明显是不对的，因此引入了反码：

$(+1)+(-1)=[0000 0001]_反+[1111 1110]_反=[1111 1111]_反=[1000 0000]_原=-0$

这时问题出现在了符号位上，机器会认为+0(`0000 0000`)和-0(`1000 0000`)是两个数，但是实际上0带符号是没有意义的。

这个时候就需要补码来解决这个问题：

$(+1)+(-1)=[0000 0001]_补+[1111 1111]_补=[0000 0000]_补=[0000 0000]_原=0$

之前出现-0的问题不存在了，而且可以用`1000 0000`，即-0，表示-128。

❗️因此，计算机是采用补码的方式存储数值的。并且补码表示的数值范围为-128～127，即$-2^7\sim 2^7-1$，（以8位为例）。 

# 3.类型转换

当在程序的某处我们使用了一种类型而其实对象应该取另一种类型时，程序会自动进行类型转换。

例如：

```c++
bool b=42;//b为真
int i=b;//i=1
i=3.14;//i=3
double pi=i;//pi=3
unsigned char c=-1;//假设char占8比特，c的值为255
```

# X.参考资料

1.[原码、反码、补码详解（作者：张子秋）](https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html)