---
layout:     post
title:      【C++基础】第九课：复合类型
subtitle:   引用，指针
date:       2019-06-27
author:     x-jeff
header-img: blogimg/20190627.jpg
catalog: true
tags:
    - C++ Series
---
>【C++基础】系列博客为参考[《C++ Primer中文版（第5版）》](https://www.phei.com.cn/module/goods/wssd_content.jsp?bookid=37655)（**C++11标准**）一书，自己所做的读书笔记。  
>本文为原创文章，未经本人允许，禁止转载。转载请注明出处。

# 1.复合类型

**复合类型**是指基于其他类型定义的类型。

最常见的两种即为：**指针**和**引用**。

## 1.1.声明语句

例如一条简单的声明/定义语句：

```c++
int *p;
```

由一个**基本数据类型（即`int`）**和紧随其后的一个**声明符（即`*p`）**组成。其中`*`作为声明符的一部分，也称为**类型修饰符**。

# 2.引用

**引用**指引用另外一种类型，通过将声明符写成`&d`的形式来定义引用类型。

```c++
int ival=1024;
int &refVal=ival;//refVal指向ival（是ival的另一个名字）
int &refVal2;//报错：引用必须被初始化
```

一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值**绑定**在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此⚠️**引用必须初始化**⚠️。

## 2.1.引用即别名

❗️引用并非对象，它只是为一个已经存在的对象所起的另外一个名字。

定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的：

```c++
refVal=2;//此时：ival=refVal=2
int ii=refVal;//此时：ival=refVal=ii=2
```

为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取了与引用绑定的对象的值。

```c++
int &refVal3=refVal;
refVal3=5;//此时：ival=refVal=refVal3=5
```

⚠️因为引用本身不是一个对象，所以不能定义引用的引用。

## 2.2.引用的定义

允许在一条语句中定义多个引用，例如：

```c++
int i=1024,i2=2048;
int &r=i,r2=i2;
int i3=1024,&ri=i3;
int &r3=i3,&r4=i2;
```

⚠️引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起：

```c++
int &refVal4=10;//错误：不能与字面值绑定在一起
double dval=3.14;
int &refVal5=dval;//错误：类型不匹配
```

# 3.指针

与引用类似，指针也实现了对其他对象的间接访问。

但指针与引用相比又有很多不同点：

1. 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。
2. 指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

定义指针类型的方法将声明符写成`*d`的形式，其中`d`是变量名。如果在一条语句中定义了几个指针变量，每个变量前面都必须有符号`*`：

```c++
int *ip1,*ip2;//ip1和ip2都是指向int型对象的指针
double dp,*dp2;
```

（⚠️注意是`ip1`是指向int型对象的指针，而不是`*ip1`是指向int型对象的指针！）

## 3.1.获取对象的指针

📌指针存放某个对象的**地址**，要想获取该地址，需要使用**取地址符（操作符&）**。

```c++
int ival=42;
int *p=&ival;//p存放变量ival的地址，或者说p是指向变量ival的指针
```

⚠️因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。

⚠️指针的类型都要和它所指向的对象严格匹配。

## 3.2.指针值

指针的值（即地址）应属下列4种状态之一：

1. 指向一个对象。
2. 指向紧邻对象所占空间的下一个位置。
3. 空指针，意味着指针没有指向任何对象。
4. 无效指针，也就是上述情况之外的指针。

## 3.3.利用指针访问对象

如果指针指向了一个对象，则允许使用**解引用符（操作符\*）**来访问该对象。

```c++
int ival=42;
int *p=&ival;//*p输出值为42
*p=21;//⚠️此时：ival=21。为*p赋值实际上是为p所指的对象赋值，即ival
int *p1=21;//⚠️报错，不能通过字面值定义指针
```

对指针解引用会得出所指的对象。

⚠️解引用操作仅适用于那些确实指向了某个对象的有效指针。

## 3.4.`&`和`*`的多重含义

`&`和`*`即可作为运算符，即取地址符和解引用符，还可作为声明符中的一部分。

```c++
int i=42;
int &r=i;//&为声明的一部分，r是一个引用
int *p;//*为声明的一部分，p是一个指针
p=&i;//&为取地址符
*p=i;//*为解引用符
int &r2=*p;//&为声明的一部分，*是解引用符
```

上述例子中，同一符号的含义截然不同，完全可以当作不同的符号来看待。

## 3.5.空指针

**空指针**不指向任何对象。

生成空指针的几个方法：

```c++
int *p1=nullptr;//C++11
int *p2=0;
int *p3=NULL;//需要首先#include cstdlib
```

过去的程序还会用到一个名为`NULL`的**预处理变量**来给指针赋值，这个变量在头文件`cstdlib`中定义，它的值就是0。

👉**预处理器：**是运行于编译过程之前的一段程序。预处理变量不属于命名空间`std`，它由预处理器负责管理，因此我们可以直接使用预处理变量而无须在前面加上`std::`。当用到一个预处理变量时，预处理器会自动地将它替换为实际值，因此用`NULL`初始化指针和用0初始化指针是一样的。

⚠️把int变量直接赋给指针是错误的操作，即使int变量的值恰好等于0也不行。

```c++
int zero=0;
int *pi;
pi=zero;//错误
```

## 3.6.其他指针操作

```c++
int ival=1024;
int *pi=0;
int *pi2=&ival;
if(pi);//条件为false
if (pi2);//条件为true
```

❗️任何非0指针对应的条件值都是true。

## 3.7.`void*`指针

`void*`是一种特殊的指针类型，可用于存放任意对象的地址。一个`void*`指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解。

⚠️`void*`没办法访问内存空间中所存的对象。不能直接操作`void*`指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。

举两个例子说明一下`void*`的局限：

```c++
int main(){	double obj = 3.1415, *pd = &obj, *demo = nullptr;	void *pv = &obj;	demo = pd;//correct	demo = pv;//⚠️error：无法传址	std::cout <<pv<< std::endl;	std::cout <<pv<< std::endl;}```

```c++
int main(){	double obj = 3.1415, *pd = &obj;	void *pv = &obj;	std::cout <<*pv<< std::endl;//错误：无法输出*pv	std::cout << pv << std::endl;//正确：可以输出pv（即地址）}
```

# 4.复合类型的声明

```c++
int *p1,p2;//p1是指向int的指针，p2是int
```

## 4.1.指向指针的指针

📌一般来说，声明符中修饰符的个数并没有限制。

```c++
int ival=1024;
int *pi=&ival;
int **ppi=&pi;
```

`ival`、`pi`、`ppi`之间的关系如下图所示：

![](https://github.com/x-jeff/BlogImage/raw/master/CPPSeries/Lesson9/9x1.png)

## 4.2.指向指针的引用

```c++
int i=42;
int *p;
int *&r=p;//r是一个对指针p的引用

r=&i;//给r赋值&i就是令p指向i
*r=0;//解引用r得到i，也就是p指向的对象，将i的值改为0
```

❗️要理解`r`的类型到底是什么，最简单的办法是**从右向左**阅读`r`的定义。离变量名最近的符号对变量的类型有最直接的影响，因此`r`是一个引用。声明符的其余部分用以确定`r`引用的类型是什么，此例中的`*`说明`r`引用的是一个指针。最后，声明的基本数据类型部分指出`r`引用的是一个`int`指针。

## 4.3.指向引用的指针/引用

2.1部分和3.1部分提到过不存在指向引用的指针或者引用，所以下述例子是错误的：

```c++
int val=10;
int &*p=val;//错误
```