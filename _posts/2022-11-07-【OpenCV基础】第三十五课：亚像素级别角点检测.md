---
layout:     post
title:      ã€OpenCVåŸºç¡€ã€‘ç¬¬ä¸‰åäº”è¯¾ï¼šäºšåƒç´ çº§åˆ«è§’ç‚¹æ£€æµ‹
subtitle:   cv::cornerSubPix
date:       2022-11-07
author:     x-jeff
header-img: blogimg/20221107.jpg
catalog: true
tags:
    - OpenCV Series
---
>æœ¬æ–‡ä¸ºåŸåˆ›æ–‡ç« ï¼Œæœªç»æœ¬äººå…è®¸ï¼Œç¦æ­¢è½¬è½½ã€‚è½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

# 1.åŸç†

å®é™…æƒ…å†µä¸‹å‡ ä¹æ‰€æœ‰çš„è§’ç‚¹éƒ½ä¸ä¼šæ˜¯ä¸€ä¸ªçœŸæ­£çš„å‡†ç¡®åƒç´ ç‚¹ï¼Œæ¯”å¦‚$(100,5)$ï¼Œå®é™…ä¸Šå¯èƒ½æ˜¯$(100.234,5.789)$ã€‚

äºšåƒç´ çº§åˆ«çš„è§’ç‚¹æ£€æµ‹åŸºäºçš„ä¸€ä¸ªé‡è¦æ¡ä»¶æ˜¯ï¼šä»äºšåƒç´ ç‚¹$q$åˆ°ä½äº$q$é‚»åŸŸå†…ä»»æ„åƒç´ ç‚¹$p$çš„å‘é‡éƒ½ä¸$p$å¤„çš„å›¾åƒæ¢¯åº¦æ­£äº¤ï¼š

$$DI_{p_i}^T \cdot (q-p_i) = 0 \tag{1}$$

å…¶ä¸­ï¼Œ$DI_{p_i}$æ˜¯åƒç´ ç‚¹$p_i$å¤„çš„å›¾åƒæ¢¯åº¦ï¼š

$$DI_{p_i} = \begin{bmatrix} dx \\ dy \end{bmatrix}, \quad DI_{p_i} ^T= \begin{bmatrix} dx & dy \end{bmatrix}, \quad DI_{p_i} \cdot DI_{p_i} ^T = \begin{bmatrix} dxdx & dxdy \\ dxdy & dydy \\  \end{bmatrix} \tag{2}$$

é‚£ä¹ˆå¼(1)ä¸ºä»€ä¹ˆä¼šä¸€ç›´æˆç«‹å‘¢ï¼Ÿæˆ‘ä»¬ç”¨ä¸‹å›¾è¿›è¡Œä¸€ä¸‹è§£é‡Šã€‚

![](https://xjeffblogimg.oss-cn-beijing.aliyuncs.com/BLOGIMG/BlogImage/OpenCVSeries/Lesson35/35x1.jpg)

$p_i$çš„ä½ç½®æˆ‘ä»¬åªè€ƒè™‘ä¸¤ç§å¯èƒ½ï¼š

1. $p_i$ä½äºä¸€ç‰‡ç°åº¦å€¼åŸºæœ¬æ²¡æœ‰å˜åŒ–çš„åŒºåŸŸï¼Œå³ä¸Šå›¾ä¸­çš„$p_0$ã€‚
2. $p_i$ä½äºç°åº¦å€¼å˜åŒ–çš„è¾¹ç¼˜ï¼Œå³ä¸Šå›¾ä¸­çš„$p_1$ã€‚

å¦‚æœæ˜¯ç¬¬ä¸€ç§æƒ…å†µï¼šæ­¤æ—¶$DI_{p_i}$å‡ ä¹æ˜¯ç­‰äº0çš„ï¼Œæ‰€ä»¥å¼(1)æˆç«‹ã€‚

å¦‚æœæ˜¯ç¬¬äºŒç§æƒ…å†µï¼šæ­¤æ—¶$DI_{p_i}$çš„æ–¹å‘å¦‚ä¸Šå›¾ä¸­çº¢è‰²ç®­å¤´æ‰€ç¤ºï¼Œå…¶å’Œå‘é‡$\vec{q p_i}$æ˜¯æ­£äº¤çš„ï¼Œä¸¤ä¸ªæ­£äº¤å‘é‡çš„ç‚¹ç§¯è‡ªç„¶æ˜¯0ã€‚

å°†å¼(1)ç§»é¡¹ï¼š

$$DI_{p_i}^T \cdot q = DI_{p_i}^T \cdot p_i \tag{3}$$

æœ€å°äºŒä¹˜æ³•æ±‚è§£ï¼š

$$DI_{p_i} \cdot DI_{p_i}^T \cdot q = DI_{p_i} \cdot DI_{p_i}^T \cdot p_i \tag{4}$$

é€šå¸¸$q$ç‚¹åªæœ‰ä¸€ä¸ªï¼Œä½†æ˜¯$p_i$æœ‰å¤šä¸ªï¼ˆå‡è®¾æœ‰$N$ä¸ªï¼‰ï¼Œæ‰€ä»¥å¼(4)å¯è¡¨ç¤ºä¸ºï¼š

$$\left\{ \begin{array}{c} DI_{p_0} \cdot DI_{p_0}^T \cdot q = DI_{p_0} \cdot DI_{p_0}^T \cdot p_0  \\ DI_{p_1} \cdot DI_{p_1}^T \cdot q = DI_{p_1} \cdot DI_{p_1}^T \cdot p_1 \\ \cdots  \\ DI_{p_N} \cdot DI_{p_N}^T \cdot q = DI_{p_N} \cdot DI_{p_N}^T \cdot p_N \end{array} \right. \tag{5}$$

æŠŠæ–¹ç¨‹ç»„(5)çš„å·¦å³åˆ†åˆ«åŠ èµ·æ¥ï¼š

$$\sum_{i=0}^N ( DI_{p_i} \cdot DI_{p_i}^T) \cdot q =\sum_{i=0}^N ( DI_{p_i} \cdot DI_{p_i}^T \cdot p_i) \tag{6}$$

å³ï¼š

$$q =\left[ \sum_{i=0}^N (DI_{p_i} \cdot DI_{p_i}^T)\right] ^{-1} \cdot \sum_{i=0}^N \left( DI_{p_i} \cdot DI_{p_i}^T \cdot p_i \right) \tag{7}$$

æ­¤å¤–ï¼Œç”±äºå„ä¸ª$p_i$ç‚¹åˆ°$q$çš„è·ç¦»ä¸ä¸€æ ·ï¼Œæˆ‘ä»¬å¯ä»¥å°†$p_i$èµ‹äºˆä¸åŒçš„æƒé‡ï¼š

$$q =\left[ \sum_{i=0}^N (DI_{p_i} \cdot DI_{p_i}^T \cdot w_i)\right] ^{-1} \cdot \sum_{i=0}^N \left( DI_{p_i} \cdot DI_{p_i}^T \cdot p_i \cdot w_i \right) \tag{8}$$

# 2.`cv::cornerSubPix`

```c++
void cornerSubPix( 
	InputArray image, 
	InputOutputArray corners,
	Size winSize, 
	Size zeroZone,
	TermCriteria criteria 
);
```

å‚æ•°è¯¦è§£ï¼š

1. `InputArray image`ï¼šè¾“å…¥å›¾åƒï¼Œéœ€è¦ä¸ºå•é€šé“8-bitï¼ˆæ¯”å¦‚ç°åº¦å›¾åƒï¼‰æˆ–floatç±»å‹å›¾åƒã€‚
2. `InputOutputArray corners`ï¼šè¾“å…¥ä¸ºæ£€æµ‹åˆ°çš„è§’ç‚¹ï¼ˆåƒç´ çº§åˆ«ï¼‰ï¼Œè¾“å‡ºä¸ºrefineåçš„äºšåƒç´ çº§åˆ«çš„è§’ç‚¹ã€‚
3. `Size winSize`ï¼šç”¨äºé™å®š$p_i$çš„æœç´¢èŒƒå›´ã€‚æ¯”å¦‚ï¼ŒwinSize=Size(5,5)ï¼Œåˆ™æœç´¢èŒƒå›´ä¸º$(5 \* 2 +1) \times (5 \* 2 +1) = 11 \times 11$ã€‚
4. `Size zeroZone`ï¼šè§ç¬¬3éƒ¨åˆ†çš„è§£é‡Šã€‚
5. `TermCriteria criteria`ï¼šè¿­ä»£ä¼˜åŒ–çš„ç»ˆæ­¢æ¡ä»¶ã€‚å¯ä»¥æ˜¯ä»¥ä¸‹ä¸¤ç§æ¡ä»¶å…¶ä¸€æˆ–è€…äºŒè€…å…¼æœ‰ï¼š
	* `TermCriteria::MAX_ITER`ï¼šæœ€å¤§è¿­ä»£æ¬¡æ•°ã€‚
	* `TermCriteria::EPS`ï¼šæœ€å°è¯¯å·®ã€‚

# 3.æºç è§£æ

```c++
void cv::cornerSubPix( InputArray _image, InputOutputArray _corners,
                       Size win, Size zeroZone, TermCriteria criteria )
{
    CV_INSTRUMENT_REGION();

    const int MAX_ITERS = 100;
    int win_w = win.width * 2 + 1, win_h = win.height * 2 + 1;
    int i, j, k;
    int max_iters = (criteria.type & CV_TERMCRIT_ITER) ? MIN(MAX(criteria.maxCount, 1), MAX_ITERS) : MAX_ITERS;
    double eps = (criteria.type & CV_TERMCRIT_EPS) ? MAX(criteria.epsilon, 0.) : 0;
    eps *= eps; // use square of error in comparison operations

    cv::Mat src = _image.getMat(), cornersmat = _corners.getMat();
    int count = cornersmat.checkVector(2, CV_32F);
    CV_Assert( count >= 0 );
    Point2f* corners = cornersmat.ptr<Point2f>();

    if( count == 0 )
        return;

    CV_Assert( win.width > 0 && win.height > 0 );
    CV_Assert( src.cols >= win.width*2 + 5 && src.rows >= win.height*2 + 5 );
    CV_Assert( src.channels() == 1 );

    Mat maskm(win_h, win_w, CV_32F), subpix_buf(win_h+2, win_w+2, CV_32F);
    float* mask = maskm.ptr<float>();

    for( i = 0; i < win_h; i++ )
    {
        float y = (float)(i - win.height)/win.height;
        float vy = std::exp(-y*y);
        for( j = 0; j < win_w; j++ )
        {
            float x = (float)(j - win.width)/win.width;
            mask[i * win_w + j] = (float)(vy*std::exp(-x*x));
        }
    }

    // make zero_zone
    if( zeroZone.width >= 0 && zeroZone.height >= 0 &&
        zeroZone.width * 2 + 1 < win_w && zeroZone.height * 2 + 1 < win_h )
    {
        for( i = win.height - zeroZone.height; i <= win.height + zeroZone.height; i++ )
        {
            for( j = win.width - zeroZone.width; j <= win.width + zeroZone.width; j++ )
            {
                mask[i * win_w + j] = 0;
            }
        }
    }

    // do optimization loop for all the points
    for( int pt_i = 0; pt_i < count; pt_i++ )
    {
        Point2f cT = corners[pt_i], cI = cT;
        int iter = 0;
        double err = 0;

        do
        {
            Point2f cI2;
            double a = 0, b = 0, c = 0, bb1 = 0, bb2 = 0;

            getRectSubPix(src, Size(win_w+2, win_h+2), cI, subpix_buf, subpix_buf.type());
            const float* subpix = &subpix_buf.at<float>(1,1);

            // process gradient
            for( i = 0, k = 0; i < win_h; i++, subpix += win_w + 2 )
            {
                double py = i - win.height;

                for( j = 0; j < win_w; j++, k++ )
                {
                    double m = mask[k];
                    double tgx = subpix[j+1] - subpix[j-1];
                    double tgy = subpix[j+win_w+2] - subpix[j-win_w-2];
                    double gxx = tgx * tgx * m;
                    double gxy = tgx * tgy * m;
                    double gyy = tgy * tgy * m;
                    double px = j - win.width;

                    a += gxx;
                    b += gxy;
                    c += gyy;

                    bb1 += gxx * px + gxy * py;
                    bb2 += gxy * px + gyy * py;
                }
            }

            double det=a*c-b*b;
            if( fabs( det ) <= DBL_EPSILON*DBL_EPSILON )
                break;

            // 2x2 matrix inversion
            double scale=1.0/det;
            cI2.x = (float)(cI.x + c*scale*bb1 - b*scale*bb2);
            cI2.y = (float)(cI.y - b*scale*bb1 + a*scale*bb2);
            err = (cI2.x - cI.x) * (cI2.x - cI.x) + (cI2.y - cI.y) * (cI2.y - cI.y);
            cI = cI2;
            if( cI.x < 0 || cI.x >= src.cols || cI.y < 0 || cI.y >= src.rows )
                break;
        }
        while( ++iter < max_iters && err > eps );

        // if new point is too far from initial, it means poor convergence.
        // leave initial point as the result
        if( fabs( cI.x - cT.x ) > win.width || fabs( cI.y - cT.y ) > win.height )
            cI = cT;

        corners[pt_i] = cI;
    }
}
```

ğŸ‘‰ç¬¬ä¸€æ­¥ï¼šè¯»å…¥ä¼ è¿›æ¥çš„å‚æ•°ã€‚

```c++
    CV_INSTRUMENT_REGION();

    const int MAX_ITERS = 100;
    int win_w = win.width * 2 + 1, win_h = win.height * 2 + 1;
    int i, j, k;
    int max_iters = (criteria.type & CV_TERMCRIT_ITER) ? MIN(MAX(criteria.maxCount, 1), MAX_ITERS) : MAX_ITERS;
    double eps = (criteria.type & CV_TERMCRIT_EPS) ? MAX(criteria.epsilon, 0.) : 0;
    eps *= eps; // use square of error in comparison operations

    cv::Mat src = _image.getMat(), cornersmat = _corners.getMat();
    int count = cornersmat.checkVector(2, CV_32F);
    CV_Assert( count >= 0 );
    Point2f* corners = cornersmat.ptr<Point2f>();

    if( count == 0 )
        return;

    CV_Assert( win.width > 0 && win.height > 0 );
    CV_Assert( src.cols >= win.width*2 + 5 && src.rows >= win.height*2 + 5 );
    CV_Assert( src.channels() == 1 );
```

è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ä¼ è¿›æ¥çš„æœ€å°è¯¯å·®epsåšäº†ä¸€ä¸ªå¹³æ–¹çš„å¤„ç†ï¼Œæ‰€ä»¥å®é™…ç”¨çš„è¯¯å·®é˜ˆå€¼æ˜¯eps\*epsã€‚

ğŸ‘‰ç¬¬äºŒæ­¥ï¼šç”Ÿæˆæƒé‡çŸ©é˜µã€‚è¿™é‡Œä½¿ç”¨çš„æ˜¯é«˜æ–¯åˆ†å¸ƒã€‚

```c++
    Mat maskm(win_h, win_w, CV_32F), subpix_buf(win_h+2, win_w+2, CV_32F);
    float* mask = maskm.ptr<float>();

    for( i = 0; i < win_h; i++ )
    {
        float y = (float)(i - win.height)/win.height;
        float vy = std::exp(-y*y);
        for( j = 0; j < win_w; j++ )
        {
            float x = (float)(j - win.width)/win.width;
            mask[i * win_w + j] = (float)(vy*std::exp(-x*x));
        }
    }

    // make zero_zone
    if( zeroZone.width >= 0 && zeroZone.height >= 0 &&
        zeroZone.width * 2 + 1 < win_w && zeroZone.height * 2 + 1 < win_h )
    {
        for( i = win.height - zeroZone.height; i <= win.height + zeroZone.height; i++ )
        {
            for( j = win.width - zeroZone.width; j <= win.width + zeroZone.width; j++ )
            {
                mask[i * win_w + j] = 0;
            }
        }
    }
```

å‡è®¾æˆ‘ä»¬ä¼ è¿›æ¥çš„winSize=Size(5,5)ï¼Œé‚£å®é™…æœç´¢çª—å£å¤§å°ä¸º$11 \times 11$ï¼Œç”Ÿæˆçš„é«˜æ–¯åˆ†å¸ƒæƒé‡çŸ©é˜µè§ä¸‹ï¼ˆè¶Šé è¿‘ä¸­å¿ƒç‚¹ï¼Œæƒé‡è¶Šå¤§ï¼Œä¸­å¿ƒç‚¹æƒé‡ä¸º1ï¼‰ï¼š

```
0.135335 0.19398 0.256661 0.313486 0.353455 0.367879 0.353455 0.313486 0.256661 0.19398 0.135335 
0.19398 0.278037 0.367879 0.449329 0.506617 0.527292 0.506617 0.449329 0.367879 0.278037 0.19398 
0.256661 0.367879 0.486752 0.594521 0.67032 0.697676 0.67032 0.594521 0.486752 0.367879 0.256661 
0.313486 0.449329 0.594521 0.726149 0.818731 0.852144 0.818731 0.726149 0.594521 0.449329 0.313486 
0.353455 0.506617 0.67032 0.818731 0.923116 0.960789 0.923116 0.818731 0.67032 0.506617 0.353455 
0.367879 0.527292 0.697676 0.852144 0.960789 1 0.960789 0.852144 0.697676 0.527292 0.367879 
0.353455 0.506617 0.67032 0.818731 0.923116 0.960789 0.923116 0.818731 0.67032 0.506617 0.353455 
0.313486 0.449329 0.594521 0.726149 0.818731 0.852144 0.818731 0.726149 0.594521 0.449329 0.313486 
0.256661 0.367879 0.486752 0.594521 0.67032 0.697676 0.67032 0.594521 0.486752 0.367879 0.256661 
0.19398 0.278037 0.367879 0.449329 0.506617 0.527292 0.506617 0.449329 0.367879 0.278037 0.19398 
0.135335 0.19398 0.256661 0.313486 0.353455 0.367879 0.353455 0.313486 0.256661 0.19398 0.135335 
```

è¿™é‡Œç”¨çš„ç”Ÿæˆé«˜æ–¯åˆ†å¸ƒæƒé‡çŸ©é˜µçš„å…¬å¼ä¸ºï¼š

$$e^{-\left[ \left( \frac{x-\mu_x}{\mu_x} \right)^2 + \left( \frac{y-\mu_y}{\mu_y} \right)^2 \right] }$$

å¦‚æœæˆ‘ä»¬ä¼ è¿›æ¥çš„winSize=Size(5,5)ï¼Œé‚£å°±æœ‰$\mu_x = \mu_y = 5, \  x\in [0,10], \  y\in [0,10]$ã€‚

è€Œä¼ è¿›æ¥çš„å‚æ•°zeroZoneç”¨äºå±è”½æ‰æŸäº›ä½ç½®ä¸Šçš„æƒé‡ï¼Œåšæ³•æ˜¯å°†è¯¥ä½ç½®çš„æƒé‡ç½®ä¸º0ï¼Œå³è®¡ç®—æ—¶ä¸è€ƒè™‘è¿™äº›ä½ç½®ä¸Šçš„åƒç´ ç‚¹$p_i$ã€‚zeroZoneä¹Ÿæ˜¯ä»¥æœç´¢çª—å£çš„ä¸­å¿ƒä¸ºä¸­å¿ƒçš„ã€‚å¦‚æœzeroZone=Size(-1,-1)ï¼Œåˆ™æœç´¢çª—å£å†…çš„æ‰€æœ‰ç‚¹éƒ½ä¸ä¼šè¢«å±è”½ã€‚

ğŸ‘‰ç¬¬ä¸‰æ­¥ï¼šè®¡ç®—äºšåƒç´ è§’ç‚¹

```c++
    // do optimization loop for all the points
    for( int pt_i = 0; pt_i < count; pt_i++ )
    {
        Point2f cT = corners[pt_i], cI = cT;
        int iter = 0;
        double err = 0;

        do
        {
            Point2f cI2;
            double a = 0, b = 0, c = 0, bb1 = 0, bb2 = 0;

            getRectSubPix(src, Size(win_w+2, win_h+2), cI, subpix_buf, subpix_buf.type());
            const float* subpix = &subpix_buf.at<float>(1,1);

            // process gradient
            for( i = 0, k = 0; i < win_h; i++, subpix += win_w + 2 )
            {
                double py = i - win.height;

                for( j = 0; j < win_w; j++, k++ )
                {
                    double m = mask[k];
                    double tgx = subpix[j+1] - subpix[j-1];
                    double tgy = subpix[j+win_w+2] - subpix[j-win_w-2];
                    double gxx = tgx * tgx * m;
                    double gxy = tgx * tgy * m;
                    double gyy = tgy * tgy * m;
                    double px = j - win.width;

                    a += gxx;
                    b += gxy;
                    c += gyy;

                    bb1 += gxx * px + gxy * py;
                    bb2 += gxy * px + gyy * py;
                }
            }

            double det=a*c-b*b;
            if( fabs( det ) <= DBL_EPSILON*DBL_EPSILON )
                break;

            // 2x2 matrix inversion
            double scale=1.0/det;
            cI2.x = (float)(cI.x + c*scale*bb1 - b*scale*bb2);
            cI2.y = (float)(cI.y - b*scale*bb1 + a*scale*bb2);
            err = (cI2.x - cI.x) * (cI2.x - cI.x) + (cI2.y - cI.y) * (cI2.y - cI.y);
            cI = cI2;
            if( cI.x < 0 || cI.x >= src.cols || cI.y < 0 || cI.y >= src.rows )
                break;
        }
        while( ++iter < max_iters && err > eps );

        // if new point is too far from initial, it means poor convergence.
        // leave initial point as the result
        if( fabs( cI.x - cT.x ) > win.width || fabs( cI.y - cT.y ) > win.height )
            cI = cT;

        corners[pt_i] = cI;
    }
```

æœ€å¤–å±‚çš„forå¾ªç¯ç”¨äºéå†æ¯ä¸€ä¸ªè§’ç‚¹ã€‚å†…å±‚çš„doå¾ªç¯ç”¨äºå¯¹æŸä¸€è§’ç‚¹è¿›è¡Œrefineã€‚é‡ç‚¹å°±æ˜¯è¿™ä¸ªdoå¾ªç¯ã€‚é¦–å…ˆä»¥æŸä¸€è§’ç‚¹ä¸ºä¸­å¿ƒæˆªå–æœç´¢çª—å£ï¼Œè¿™é‡Œ$p_i$çš„æ¨ªçºµåæ ‡åˆ†åˆ«ç”¨pyå’Œpxè¡¨ç¤ºï¼ˆéƒ½æ˜¯ç›¸å¯¹äºçª—å£ä¸­å¿ƒçš„ç›¸å¯¹åæ ‡ï¼‰ï¼Œè¿™é‡Œé‡‡ç”¨å¼(8)çš„è®¡ç®—ï¼Œå…ˆæ¥çœ‹å¼(8)çš„å‰åŠéƒ¨åˆ†ï¼Œå…¶ä¸­

$$DI_{p_i} \cdot DI_{p_i}^T \cdot w_i$$

ç”¨ä»£ç é‡Œçš„ç¬¦å·è¡¨ç¤ºå°±æ˜¯ï¼š

$$\begin{bmatrix} gxx & gxy \\ gxy & gyy \end{bmatrix}$$

åŠ ä¸Šæ±‚å’Œä¹‹å

$$ \sum_{i=0}^N (DI_{p_i} \cdot DI_{p_i}^T \cdot w_i)$$

ç”¨ä»£ç é‡Œçš„ç¬¦å·è¡¨ç¤ºå°±æ˜¯ï¼š

$$\begin{bmatrix} \sum gxx & \sum gxy \\ \sum gxy & \sum gyy \end{bmatrix} = \begin{bmatrix} a & b \\ b & c \end{bmatrix}$$

å¼(8)çš„ååŠéƒ¨åˆ†

$$DI_{p_i} \cdot DI_{p_i}^T \cdot p_i \cdot w_i$$

ç”¨ä»£ç é‡Œçš„ç¬¦å·è¡¨ç¤ºå°±æ˜¯ï¼š

$$\begin{bmatrix} gxx & gxy \\ gxy & gyy \end{bmatrix} \begin{bmatrix} px \\ py \end{bmatrix} = \begin{bmatrix} gxx * px + gxy * py \\ gxy * px + gyy * py \end{bmatrix}$$

åŠ ä¸Šæ±‚å’Œä¹‹å

$$\sum_{i=0}^N \left( DI_{p_i} \cdot DI_{p_i}^T \cdot p_i \cdot w_i \right)$$

ç”¨ä»£ç é‡Œçš„ç¬¦å·è¡¨ç¤ºå°±æ˜¯ï¼š

$$\begin{bmatrix} \sum (gxx * px + gxy * py) \\ \sum (gxy * px + gyy * py) \end{bmatrix} = \begin{bmatrix} bb1 \\ bb2 \end{bmatrix} $$

ç„¶åå¯¹äºå¼(8)çš„å‰åŠéƒ¨åˆ†ï¼Œæˆ‘ä»¬è¿˜éœ€è¦æ±‚å…¶é€†çŸ©é˜µï¼Œ$2\times 2$çŸ©é˜µçš„é€†çŸ©é˜µçš„è®¡ç®—è§ä¸‹ï¼š

$$A^{-1} = \begin{bmatrix} A_{11} & A_{12} \\ A_{21} & A_{22} \\  \end{bmatrix}^{-1} = \frac{1}{A_{11}A_{22} - A_{12}A_{21}} \begin{bmatrix} A_{22} & -A_{12} \\ -A_{21} & A_{11} \\  \end{bmatrix}$$

é‚£ä¹ˆç”¨ä»£ç é‡Œçš„ç¬¦å·è¡¨ç¤ºå°±æ˜¯ï¼š

$$\begin{bmatrix} a & b \\ b & c \end{bmatrix}^{-1} = \frac{1}{a*c-b*b} \begin{bmatrix} c & -b \\ -b & a \end{bmatrix} = \frac{1}{\text{det}} \begin{bmatrix} c & -b \\ -b & a \end{bmatrix} = \text{scale} \begin{bmatrix} c & -b \\ -b & a \end{bmatrix} $$

æ‰€ä»¥å¼(8)æœ€ç»ˆå®Œæ•´å¯è¡¨ç¤ºä¸ºï¼š

$$\text{scale} \begin{bmatrix} c & -b \\ -b & a \end{bmatrix}  \cdot \begin{bmatrix} bb1 \\ bb2 \\ \end{bmatrix}  = \begin{bmatrix} c*\text{scale}*bb1 - b*\text{scale}*bb2 \\ - b*\text{scale}*bb1 + a*\text{scale}*bb2 \\ \end{bmatrix} $$

å› ä¸ºpx,pyæ˜¯ç›¸å¯¹åæ ‡ï¼Œæ‰€ä»¥éœ€è¦å†åŠ ä¸ŠåŸå§‹è§’ç‚¹ï¼ˆå³ä»£ç ä¸­çš„$\text{cI}$ï¼‰çš„ç»å¯¹åæ ‡ï¼Œæœ€ç»ˆå¾—åˆ°refineåçš„äºšåƒç´ åæ ‡ï¼ˆå³ä»£ç ä¸­çš„$\text{cI2}$ï¼‰ã€‚

è¿™é‡Œdoå¾ªç¯çš„è·³å‡ºæ¡ä»¶æœ‰ä¸¤ä¸ªï¼Œä¸€ä¸ªæ˜¯è¿­ä»£æ¬¡æ•°æ»¡è¶³é¢„è®¾çš„æœ€å¤§æ¬¡æ•°ï¼Œè¿™é‡Œæ¯refineä¸€ä¸ªè§’ç‚¹å°±ç®—æ˜¯ä¸€æ¬¡è¿­ä»£ï¼Œæ‰€ä»¥è¿™é‡Œçš„è¿­ä»£æ¬¡æ•°æŒ‡çš„å°±æ˜¯éœ€è¦refineçš„è§’ç‚¹çš„ä¸ªæ•°ã€‚å¦ä¸€ä¸ªæ¡ä»¶æ˜¯è¯¯å·®å°äºé˜ˆå€¼ï¼Œè¯¯å·®çš„è®¡ç®—è§ä¸‹ï¼š

$$\text{err} = (\text{cI2}.x - \text{cI.x})^2 +(\text{cI2}.y - \text{cI.y})^2 $$

å³å¾—åˆ°çš„äºšåƒç´ è§’ç‚¹åŸºæœ¬å·²ç»æ”¶æ•›ï¼Œå‡ ä¹ä¸å†å˜åŒ–äº†ã€‚

# 4.ä»£ç åœ°å€

1. [äºšåƒç´ çº§åˆ«è§’ç‚¹æ£€æµ‹](https://github.com/x-jeff/OpenCV_Code_Demo/tree/master/Demo35)

# 5.å‚è€ƒèµ„æ–™

1. [äºšåƒç´ è§’ç‚¹çš„æ±‚æ³•](https://xueyayang.github.io/pdf_posts/äºšåƒç´ è§’ç‚¹çš„æ±‚æ³•.pdf)