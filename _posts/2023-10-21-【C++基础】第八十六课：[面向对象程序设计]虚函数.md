---
layout:     post
title:      【C++基础】第八十六课：[面向对象程序设计]虚函数
subtitle:   虚函数
date:       2023-10-21
author:     x-jeff
header-img: blogimg/20190417.jpg
catalog: true
tags:
    - C++ Series
---
>【C++基础】系列博客为参考[《C++ Primer中文版（第5版）》](https://www.phei.com.cn/module/goods/wssd_content.jsp?bookid=37655)（**C++11标准**）一书，自己所做的读书笔记。  
>本文为原创文章，未经本人允许，禁止转载。转载请注明出处。

# 1.虚函数

在C++语言中，当我们使用基类的引用或指针调用一个虚成员函数时会执行[动态绑定](http://shichaoxin.com/2023/09/25/C++基础-第八十四课-面向对象程序设计-OOP-概述/#22动态绑定)。因为我们直到运行时才能知道到底调用了哪个版本的虚函数，所以所有虚函数都必须有定义。通常情况下，如果我们不使用某个函数，则无须为该函数提供定义。但是我们必须为每一个虚函数都提供定义，而不管它是否被用到了，这是因为连编译器也无法确定到底会使用哪个虚函数。

## 1.1.对虚函数的调用可能在运行时才被解析

必须要搞清楚的一点是，动态绑定只有当我们通过指针或引用调用虚函数时才会发生。

```c++
Quote base("0-201-82470-1", 50);
print_total(cout, base, 10); //调用Quote::net_price
Bulk_quote derived("0-201-82470-1", 50, 5, .19);
print_total(cout, derived, 10); //调用Bulk_quote::net_price
base = derived; //把derived的Quote部分拷贝给base
base.net_price(20); //调用Quote::net_price
```

当我们通过一个具有普通类型（非引用非指针）的表达式调用虚函数时，在编译时就会将调用的版本确定下来。例如，如果我们使用base调用net\_price，则应该运行net\_price的哪个版本是显而易见的。我们可以改变base表示的对象的值（即内容），但是不会改变该对象的类型。因此，在编译时该调用就会被解析成Quote的net\_price。

>关键概念：C++的多态性。
>
>OOP的核心思想是多态性（polymorphism）。多态性这个词源自希腊语，其含义是“多种形式”。我们把具有继承关系的多个类型称为多态类型，因为我们能使用这些类型的“多种形式”而无须在意它们的差异。引用或指针的静态类型与动态类型不同这一事实正是C++语言支持多态性的根本所在。
>
>当我们使用基类的引用或指针调用基类中定义的一个函数时，我们并不知道该函数真正作用的对象是什么类型，因为它可能是一个基类的对象也可能是一个派生类的对象。如果该函数是虚函数，则直到运行时才会决定到底执行哪个版本，判断的依据是引用或指针所绑定的对象的真实类型。
>
>另一方面，对非虚函数的调用在编译时进行绑定。类似的，通过对象进行的函数（虚函数或非虚函数）调用也在编译时绑定。对象的类型是确定不变的，我们无论如何都不可能令对象的动态类型与静态类型不一致。因此，通过对象进行的函数调用将在编译时绑定到该对象所属类中的函数版本上。
>
>当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。

## 1.2.派生类中的虚函数

当我们在派生类中覆盖了某个虚函数时，可以再一次使用virtual关键字指出该函数的性质。然而这么做并非必须，因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。

一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。

同样，派生类中虚函数的返回类型也必须与基类函数匹配。该规则存在一个例外，当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。也就是说，如果D由B派生得到，则基类的虚函数可以返回B\*而派生类的对应函数可以返回D\*，只不过这样的返回类型要求从D到B的类型转换是可访问的。

## 1.3.final和override说明符

派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然是合法的行为。编译器将认为新定义的这个函数与基类中原有的函数是相互独立的。这时，派生类的函数并没有覆盖掉基类中的版本。

如果我们使用override标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错：

```c++
struct B {
	virtual void f1(int) const;
	virtual void f2();
	void f3();
};
struct D1 : B {
	void f1(int) const override; //正确：f1与基类中的f1匹配
	void f2(int) override; //错误：B没有形如f2(int)的函数
	void f3() override; //错误：f3不是虚函数
	void f4() override; //错误：B没有名为f4的函数
};
```

我们还能把某个函数指定为final，如果我们已经把函数定义成final了，则之后任何尝试覆盖该函数的操作都将引发错误：

```c++
struct D2 : B {
	//从B继承f2()和f3()，覆盖f1(int)
	void f1(int) const final; //不允许后续的其他类覆盖f1(int)
};
struct D3 : D2 {
	void f2(); //正确：覆盖从间接基类B继承而来的f2
	void f1(int) const; //错误：D2已经将f2声明成final
};
```

final和override说明符出现在形参列表（包括任何const或引用修饰符）以及尾置返回类型之后。

## 1.4.虚函数与默认实参

和其他函数一样，虚函数也可以拥有[默认实参](http://shichaoxin.com/2022/02/26/C++基础-第三十八课-特殊用途语言特性/#2默认实参)。如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。

换句话说，如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。此时，传入派生类函数的将是基类函数定义的默认实参。如果派生类函数依赖不同的实参，则程序结果将与我们的预期不符。

>如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。

## 1.5.回避虚函数的机制

在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。使用作用域运算符可以实现这一目的，例如下面的代码：

```c++
//强行调用基类中定义的函数版本而不管baseP的动态类型到底是什么
double undiscounted = baseP->Quote::net_price(42);
```

该调用将在编译时完成解析。

什么时候我们需要回避虚函数的默认机制呢？通常是当一个派生类的虚函数调用它覆盖的基类的虚函数版本时。

>如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归。