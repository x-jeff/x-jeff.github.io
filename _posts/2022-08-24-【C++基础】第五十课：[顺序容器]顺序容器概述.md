---
layout:     post
title:      【C++基础】第五十课：[顺序容器]顺序容器概述
subtitle:   顺序容器，vector，deque，list，forward_list，array，string
date:       2022-08-24
author:     x-jeff
header-img: blogimg/20220824.jpg
catalog: true
tags:
    - C++ Series
---
>【C++基础】系列博客为参考[《C++ Primer中文版（第5版）》](https://www.phei.com.cn/module/goods/wssd_content.jsp?bookid=37655)（**C++11标准**）一书，自己所做的读书笔记。  
>本文为原创文章，未经本人允许，禁止转载。转载请注明出处。

# 1.容器

一个容器就是一些特定类型对象的集合。**顺序容器（sequential container）**为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。与之相对的，后续我们还会介绍有序和无序关联容器，则根据关键字的值来存储元素。

标准库还提供了三种容器适配器，分别为容器操作定义了不同的接口，来与容器类型适配。后续我们也会介绍适配器相关的内容。

# 2.顺序容器概述

下表列出了标准库中的顺序容器，所有顺序容器都提供了快速顺序访问元素的能力。但是，这些容器在以下方面都有不同的性能折中：

* 向容器添加或从容器中删除元素的代价。
* 非顺序访问容器中元素的代价。

![](https://github.com/x-jeff/BlogImage/raw/master/CPPSeries/Lesson50/50x1.png)

除了固定大小的array外，其他容器都提供高效、灵活的内存管理。我们可以添加和删除元素，扩张和收缩容器的大小。容器保存元素的策略对容器操作的效率有着固有的，有时是重大的影响。在某些情况下，存储策略还会影响特定容器是否支持特定操作。

例如，string和vector将元素保存在连续的内存空间中。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。但是，在这两种容器的中间位置添加或删除元素就会非常耗时：在一次插入或删除操作后，需要移动插入/删除位置之后的所有元素，来保持连续存储。而且，添加一个元素有时可能还需要分配额外的存储空间。在这种情况下，每个元素都必须移动到新的存储空间中。

list和forward\_list两个容器的设计目的是令容器任何位置的添加和删除操作都很快速。作为代价，这两个容器不支持元素的随机访问：为了访问一个元素，我们只能遍历整个容器。而且，与vector、deque和array相比，这两个容器的额外内存开销也很大。list和forward\_list的内存空间是不连续的。

deque是一个更为复杂的数据结构。与string和vector类似，deque支持快速的随机访问。与string和vector一样，在deque的中间位置添加或删除元素的代价（可能）很高。但是，在deque的两端添加或删除元素都是很快的，与list或forward\_list添加删除元素的速度相当。

forward\_list和array是新C++标准（指C++11）增加的类型。与内置数组相比，array是一种更安全、更容易使用的数组类型。与内置数组类似，array对象的大小是固定的。因此，array不支持添加和删除元素以及改变容器大小的操作。forward\_list的设计目标是达到与最好的手写的单向链表数据结构相当的性能。因此，forward\_list没有size操作，因为保存或计算其大小就会比手写链表多出额外的开销。对其他容器而言，size保证是一个快速的常量时间的操作。

>新标准库的容器比旧版本快得多。新标准库容器的性能几乎肯定与最精心优化过的同类数据结构一样好（通常会更好）。现代C++程序应该使用标准库容器，而不是更原始的数据结构，如内置数组。

## 2.1.确定使用哪种顺序容器

>通常，使用vector是最好的选择，除非你有很好的理由选择其他容器。

以下是一些选择容器的基本原则：

* 除非你有很好的理由选择其他容器，否则应使用vector。
* 如果你的程序有很多小的元素，且空间的额外开销很重要，则不要使用list或forward\_list。
* 如果程序要求随机访问元素，应使用vector或deque。
* 如果程序要求在容器的中间插入或删除元素，应使用list或forward\_list。
* 如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用deque。
* 如果程序只有在读取输入时才需要在容器中间插入元素，随后需要随机访问元素，则：
	* 首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向vector追加数据，然后再调用标准库的sort函数来重排容器中的元素，从而避免在中间位置添加元素。
	* 如果必须在中间位置插入元素，考虑在输入阶段使用list，一旦输入完成，将list中的内容拷贝到一个vector中。

如果程序既需要随机访问元素，又需要在容器中间位置插入元素，那该怎么办？答案取决于在list或forward\_list中访问元素与vector或deque中插入/删除元素的相对性能。一般来说，应用中占主导地位的操作（执行的访问操作更多还是插入/删除更多）决定了容器类型的选择。在此情况下，对两种容器分别测试应用的性能可能就是必要的了。

>如果你不确定应该使用哪种容器，那么可以在程序中只使用vector和list公共的操作：使用迭代器，不使用下标操作，避免随机访问。这样，在必要时选择使用vector或list都很方便。