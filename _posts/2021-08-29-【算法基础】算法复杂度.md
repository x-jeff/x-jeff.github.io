---
layout:     post
title:      【算法基础】算法复杂度
subtitle:   时间复杂度，空间复杂度
date:       2021-08-29
author:     x-jeff
header-img: blogimg/20210829.jpg
catalog: true
tags:
    - Algorithms Series
---        
>本文为原创文章，未经本人允许，禁止转载。转载请注明出处。

# 1.算法复杂度

**算法复杂度**是指算法在编写成可执行程序后，运行时所需要的资源，资源包括时间资源和内存资源。

**算法复杂度**分为**时间复杂度**和**空间复杂度**。

## 1.1.时间复杂度

👉**时间频度：**一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道（这种方式非常容易受运行环境的影响，在性能高的机器上跑出来的结果与在性能低的机器上跑的结果相差会很大。而且对测试时使用的数据规模也有很大关系）。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。**一个算法中的语句执行次数称为语句频度或时间频度，记为$T(n)$。**算法的时间复杂度是指执行算法所需要的计算工作量。

>相同大小的不同输入值仍可能造成算法的运行时间不同，因此我们通常使用算法的最坏情况复杂度，记为$T(n)$，定义为任何大小的输入$n$所需的最大运行时间。另一种较少使用的方法是**平均情况复杂度**，通常有特别指定才会使用。

例如求两个$n$阶方阵的乘积$C=A \times B$，其算法如下：

```c++
# define n 100 // n 可根据需要定义,这里假定为100
void MatrixMultiply(int A[n][n]，int B[n][n]，int C[n][n])
{ //右边列为各语句的频度
    int i, j, k; //1
    for(i=0; i<n; i++) {  //n+1
        for (j=0; j<n; j++) { //n*(n+1)
          C[i][j] = 0; //n²
          for (k=0; k<n; k++) {  //n²*(n+1)
            C[i][j] = C[i][j] + A[i][k] * B[k][j];  //n³
          }
        }
    }
}
```

>有的也将for循环拆开计算。以第一个for循环`for(i=0; i<n; i++)`为例，`i=0`执行$1$次；`i<n`执行$n+1$次；`i++`执行$n$次。但是这样算和合起来算只会影响$T(n)$，不影响时间复杂度。

该算法中所有语句的频度之和（即算法的时间耗费）为：

$$T(n)=2n^3+3n^2+2n+2$$

在刚才提到的时间频度中，$n$称为问题的规模，当$n$不断变化时，时间频度$T(n)$也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。

若有某个辅助函数$f(n)$，存在一个正常数$c$使得$f(n) \cdot c\geqslant T(n)$恒成立。记作$T(n)=O(f(n))$，称$O(f(n))$为算法的**渐进时间复杂度**，简称**时间复杂度**（即不包括$T(n)$这个函数的低阶项和首项系数）。

>若有某个辅助函数$f(n)$，使得当$n$趋近于无穷大时，$\frac{T(n)}{f(n)}$的极限值为不等于零的常数，则称$f(n)$是$T(n)$的同数量级函数。记作$T(n)=O(f(n))$，称$O(f(n))$为算法的渐进时间复杂度，简称时间复杂度。

在各种不同算法中，若算法中语句执行次数为一个常数，则时间复杂度为$O(1)$。另外，在时间频度不相同时，时间复杂度有可能相同，如$T(n)=n^2+3n+4$与$T(n)=4n^2+2n+1$它们的频度不同，但时间复杂度相同，都为$O(n^2)$。

按数量级递增排列，常见的时间复杂度有：

1. 常数阶$O(1)$
2. 对数阶$O(log_2 n)$
3. 线性阶$O(n)$
4. 线性对数阶$O(nlog_2 n)$
5. 平方阶$O(n^2)$
6. 立方阶$O(n^3)$
7. $k$次方阶$O(n^k)$
8. 指数阶$O(2^n)$

随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。所以上述矩阵乘法的时间复杂度为$O(n^3)$。

## 1.2.空间复杂度

一个算法在计算机存储器上所占用的存储空间包括：

1. **存储算法本身所占用的存储空间：**存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。
2. **算法的输入输出数据所占用的存储空间：**算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。
3. **算法在运行过程中临时占用的存储空间：**算法在运行过程中临时占用的存储空间随算法的不同而异，有的算法只需要占用少量的临时工作单元，而且不随问题规模的大小而改变，我们称这种算法是“就地”进行的，是节省存储的算法，有的算法需要占用的临时工作单元数与解决问题的规模$n$有关，它随着$n$的增大而增大，当$n$较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况。

**空间复杂度（Space Complexity）**是对一个算法在运行过程中临时占用存储空间大小的量度。

和时间复杂度类似，空间复杂度通常也使用大$O$记号来渐进地表示，例如$O(n)$、$O(n\log⁡ n)$、${\displaystyle O(n^{\alpha })}$、$O(2^{n})$等；其中$n$用来表示输入的长度，该值可以影响算法的空间复杂度。

就像时间复杂度的计算不考虑算法所使用的空间大小一样，空间复杂度也不考虑算法运行需要的时间长短。

✍️例子一：

```c++
int i = 1;
int j = 2;
int k = 1 + 2;
```

上述代码中临时空间并不会随着$n$的变化而变化，因此空间复杂度为$O(1)$。

✍️例子二：

```c++
int j = 0;
int[] m = new int[n];
for (int i = 1; i <= n; ++i) {
   j = i;
   j++;
}
```

上述代码中，只有创建int数组分配空间时与$n$的大小有关，而for循环内没有再分配新的空间，因此，对应的空间复杂度为$S(n) = O(n)$。

## 1.3.评估算法复杂度

![](https://github.com/x-jeff/BlogImage/raw/master/AlgorithmsSeries/Unclassified/AlgoComplexity1.png)

# 2.排序算法的算法复杂度

![](https://github.com/x-jeff/BlogImage/raw/master/AlgorithmsSeries/Unclassified/AlgoComplexity2.png)

* 均按从小到大排列。
* $k$代表数值中的“数位”个数。
* $n$代表数据规模。
* $m$代表数据的最大值减最小值。

# 3.参考资料

1. [算法复杂度（百度百科）](https://baike.baidu.com/item/算法复杂度/210801?fr=aladdin)
2. [算法的时间与空间复杂度（一看就懂）](https://zhuanlan.zhihu.com/p/50479555)
3. [时间复杂性（百度百科）](https://baike.baidu.com/item/时间复杂性/5930669?fromtitle=时间复杂度&fromid=1894057&fr=aladdin)
4. [空间复杂度（百度百科）](https://baike.baidu.com/item/空间复杂度/9664257?fr=aladdin)
5. [排序算法（wiki）](https://zh.wikipedia.org/wiki/排序算法)
6. [LeetCode0：学习算法必备知识：时间复杂度与空间复杂度的计算](https://cloud.tencent.com/developer/article/1769988)